构造函数
	带参数的构造函数可以先配置默认值
	如book类中的带参构造函数 book(char* a, double p = 5.0);
	book Gone("Gone with the Wind");//如果在调用的时候没有 传入参数，则默认为5.0
在C++中之所以利用构造函数限制类对象的创建，意图已经很明显了，
那就是要求程序设计人员在使用类创建对象的时候能够正确地进行初始化。

book(book b);//编译器无法通过
为什么拷贝构造函数的参数一定要是对象的引用呢？我们可以想一下，如果不是引用，
而是通过传值的方式将实参传递给形参，这中间本身就要经历一次对象的拷贝的过程，
而对象拷贝则必须调用拷贝构造函数，如此一来则会形成一个死循环，无解。所以拷贝构造函数的参数必须是对象的引用。
具体的解释在这里  http://www.weixueyuan.net/view/6344.html

构造函数:
由于类会自动生成拷贝构造函数，因此有些时候为了不让对象发生拷贝行为，我们可以显示声明一个拷贝构造函数，
并将其设置为private属性。这跟通过将默认构造函数设置成private属性限制对象的创建时一样的道理。
当然，禁止对象发生拷贝的需求较少，如果有这样的需求的话，知道还可以这么做就足够了，这是一个类设计的技巧。

析构函数:
在创建对象的时候系统会自动调用构造函数，在对象需要被销毁的时候同样系统会自动调用一个函数，
这个函数被称之为析构函数。析构函数就是用于回收创建对象时所消耗的各种资源
析构函数是系统自动调用，先进后出，即后创建的类先调用析构函数
类的构造函数负责对象完成初始化及其它相关操作，而析构函数则用于销毁对象时完成相应的资源释放工作。

this -->是一个指针
this指针只能用于非静态成员函数内。	即static函数不能用this指针


const关键字
const对象定义的基本语法如下：
     const 类名 对象名(实参名);
     类名 const 对象名(实参名);
一旦将对象定义为常对象之后，该对象就只能调用类中的常成员函数了。
类中const函数要这么定义
	double getprice()const;     //const关键字放在函数声明跟定义后面
	
double book::getprice()const
{
    return price;

}


static关键字
静态成员函数只能访问静态成员变量，而不能访问非静态成员变量。
普通成员函数（包括构造函数和析构函数）既可以访问普通成员变量，
同时又可以访问静态成员变量。
静态成员变量和函数不属于对象，属于类本身

